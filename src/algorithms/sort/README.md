# 정렬

정렬 알고리즘의 사전적 정의는 리스트의 엘리먼트를 특정 순서대로 나열하는 알고리즘을 의미하며,
대게 숫자식 순서 또는 사전식 순서로 정렬한다.

2005년 구글과 오라일리가 주최한 오픈소스 어워드에서 올해의 해커로 뽑히기도 한, 
루비 온 레일스를 만든 개발자 데이비드 헤너마이어 핸슨은 어느날 트위터에 아래와 같은 글을 게시했다.

> Hello, my name is David. I would fail to write bubble sort on a whiteboard.
> I look code up on the internet all the time.
> I don't do riddles.
> 
> 화이트보드에 버블 정렬을 구현해보라한다면 저는 아마 실패할 것입니다. 코드는 언제나 그냥 인터넷에서 찾았거든요.

이는 화이트보드 코딩 인터뷰에 지엽적인 문제가 나온 것을 비꼰 것으로, 수많은 개발자가 동조했다.

실제로 버블 정렬을 갑자기 구현해보라하면 쉽지 않다.
무엇보다 실무에서는 버블 정렬을 구현할 일이 없다. 매우 대표적인 비효율 알고리즘이다.

대부분의 정렬 알고리즘이 사실 그러하다.
그래도 우리가 정렬 알고리즘을 공부해두어야 하는 이유는, 알고리즘의 꽃이기 때문이다.
정렬 알고리즘의 바탕을 구성하고 있는 논리는 다른 코딩을 하는 데 많은 도움이 분명히 된다.

당장 내일보다는 장기적인 관점에서 공부를 해두자 ㅎㅎ

버블 정렬에 관한 일화로, 당시 구글 CEO 였던 에릭 슈미트는 버락 오바마에 아래와 같은 질문을 했다.

> 32 비트 정수 100만 개를 정렬하는 가장 효율적인 방법은 무엇인가요?

오바마는 답했다.
`일단 버블 정렬은 아니다.`

## 버블 정렬
그래도 한 번 버블 정렬에 대해 알아보자.

```
BubbleSort(A)
    for i from 1 to A.length
        for j from 0 to A.length - 1
            if A[j] > A[j+1]
                swap A[j] with A[j+1]
```
위 수도코드를 보면 알 수 있지만, `시간복잡도는 항상 O(n^2)` 이다.
이는 구현 가능한 가장 느린 알고리즘이다.

```java
public int[] BubbleSort(int[] A) {
    for (int i = 1; i < A.length; i++) {
        for (int j = 0; j < A.length - 1; j++) {
            if (A[j] > A[j+1]) {
                int temp = A[j];
                A[j] = A[j+1];
                A[j+1] = temp;
            }
        }
    }
    return A;
}
```


## 삽입 정렬
삽입 정렬 또한 버블 정렬처럼 단순한 정렬 알고리즘으로, 입력값이 클 때는 병합 정렬이나 퀵 정렬에 비해 성능이 떨어지기 때문에
버블 정렬과 함께 대표적인 비효율 알고리즘으로 분류된다.

그럼에도 불구하고 가진 몇 가지 이점은, 매우 단순하다는 점이다.
생각하는 프로그래밍이라는 명서를 집필한 존 벤틀리는 책에서 삽입 정렬을 단 3줄만에 C++로 구현했다.
심지어 최적화한 버전도 5줄이 채 넘지 않는다.

이로 인해, 삽입 정렬은 단독으로 쓰이는 경우는 잘 없지만, 다른 정렬 알고리즘과 병행해서 널리 쓰이는 편이다.

삽입 정렬은 한쪽에선 정렬을 완성해 나가고, 정렬되지 않은 나머지 부분에선 차례대로 이미 정렬된 부분과 비교하여 
이름 그대로 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다.

정렬된 부분에서 위치를 찾으려면 결국 매번 전체를 탐색해야 하기 때문에 뒤로 갈수록 느려질 수 밖에 없다는 단점이 있다.

## 병합 정렬
병합 정렬은 컴퓨터과학 역사상 최고의 천재라 일컫는 존 폰 노이만이 1945년에 고안한 알고리즘으로,
분할 정복의 진수를 보여주는 알고리즘이다.

최선과 최악 모두 `O(nlogn)`인 일정한 알고리즘이며, 
대부분의 경우 퀵정렬보다는 느리지만 일정한 실행 속도뿐만 아니라
무엇보다도 안정 정렬이라는 점에서 여전히 상용 라이브러리에 많이 쓰이고 있다.

## 퀵 정렬
퀵 정렬은 영국의 컴퓨터과학자 토니 호어가 1959년에 고안한 알고리즘으로,
피벗을 기준으로 좌우를 나누는 특징 때문에 파티션 교환 정렬이라고도 불린다.

병합 정렬과 마찬가지로 분할 정복 알고리즘이며 여기에 피벗이라는 개념을 통해
피벗보다 작으면 왼쪽, 크면 오른쪽과 같은 방식으로 파티셔닝하면서 쪼개나간다.

여러 가지 변형한 개선 버전이 있는데, 여기서는 N.로무토가 구현한 가장 간단한 파티션 구성을 살펴보자.

```
QuickSort(A, lo, hi)
    if lo < hi then
        pivot := partition(A, lo, hi)
        QuickSort(A, lo, pivot - 1)
        QuickSort(A, pivot + 1, hi)

partition(A, lo, hi)
    pivot := A[hi]
    i := lo
    for j := lo to hi do
        if A[j] < pivot then
            swap A[i] with A[j]
            i := i + 1
    swap A[i] with A[hi]
    return i
```
```java
public int[] QuickSort(int[] A, int lo, int hi) {
    if (lo < hi) {
        int pivot = partition(A, lo, hi);
        QuickSort(A, lo, pivot - 1);
        QuickSort(A, pivot + 1, hi);
    }
    return A;
}

public int partition(int[] A, int lo, int hi) {
    int pivot = A[hi];
    int left = lo;
    for (int right = lo; right < hi; right++) {
        if (A[right] < pivot) {
            int temp = A[left];
            A[left] = A[right];
            A[right] = temp;
            left++;
        }
    }
    int temp = A[left];
    A[left] = A[hi];
    A[hi] = temp;
    return left;
}
```
자세한 내용은 책을 참고하자.

퀵 정렬은 매우 빠르고 효율적이지만, 최악의 경우 `O(n^2)`의 시간복잡도를 가진다.
이미 정렬된 배열이 입력값으로 들어온 경우, 피벗은 매번 오른쪽에 위치하며 파티셔닝이 전혀 이루어지지 않는다.

물론 피벗 선택 알고리즘을 개선해 퀵 정렬을 좀 더 최적화하는 등 다양한 연구 결과가 많이 나와있기도 하다.

### 안정 정렬과 불안정 정렬
퀵 정렬의 또 다른 문제점은 안정 정렬이 아니라는 점이다.
안정 정렬은 중복된 값을 입력 순서와 동일하게 정렬하는 것을 말한다.

예를 들어, 아래와 같은 데이터를 가정하자.

시간순 정렬 데이터
> 서울 09:00
> 서울 09:13
> 대전 09:25
> 대구 09:30
> 서울 09:33
> 대전 09:45
> 대구 09:45

이 데이터를 `지역별`로 정렬 했을 때, 시간순서가 유지된다면 안정 정렬이고, 시간순서가 유지되지 않는다면 불안정 정렬이다.

안정 정렬 데이터
> 서울 09:00
> 서울 09:13
> 서울 09:33
> 대구 09:30
> 대구 09:45
> 대전 09:25
> 대전 09:45

불안정 정렬 데이터
> 서울 09:33
> 서울 09:00
> 서울 09:13
> 대구 09:45
> 대구 09:30
> 대전 09:45
> 대전 09:25


같은 분할 정복 알고리즘이지만, 병합 정렬은 안정 정렬이고, 퀵 정렬은 불안정 정렬이다.
심지어는 버블 정렬마저 안정 정렬이다.

입력값에 따라(이미 정렬된 경우) 버블 정렬만큼이나 느려질 수 있으면서 불안정 정렬인 탓에,
실무에서는 퀵 정렬보다는 병합 정렬이 활발히 쓰이고 있다.

자바의 `Arrays.sort()` 는 병합 정렬을 개선해 만든 팀소트(TimSort)를 기본 알고리즘으로 채택해 사용하고 있으며,
원시 자료형처럼 안정성이 중요하지 않은 경우에만 제한적으로 퀵 정렬(듀얼 피벗 퀵 정렬)을 활용하고 있다.

참고로 팀소트는 파이썬 개발자가 만들었으며, 우수한 성능으로 인해 다른 언어에 적극적으로 채택되었다.
